<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>D3: Vertical axis added</title>
	<script type="application/javascript" src="d3.v3.js"></script>
	<script type="application/javascript" src="http://d3js.org/d3.v3.js"></script>
	<script type="application/javascript" src="21.js"></script>
	<style type="text/css">

		.axis path,
		.axis line {
			fill: none;
			stroke: black;
			shape-rendering: crispEdges;
		}

		.axis text {
			font-family: sans-serif;
			font-size: 11px;
		}
		#drag-me {
			width: 25%;
			height: 100%;
			margin: 10%;

			background-color: #29e;
			color: white;

			border-radius: 0.75em;
			padding: 4%;

			-webkit-transform: translate(0px, 0px);
			transform: translate(0px, 0px);
		}

		#drag-me::before {
			content: "#" attr(id);
			font-weight: bold;
		}
	</style>
</head>
<body>
<script src="fileAPI.js"></script>

<form id="mark">
	<p><b>Отметки:</b><br>
</form>

<div>
	<!-- "js-fileapi-wrapper" -- обязательный class -->
	<div class="js-fileapi-wrapper upload-btn" id="choose">
		<div class="upload-btn__txt">Choose files</div>
		<input name="files" type="file" multiple />
	</div>
	<div id="images"><!-- предпросмотр --></div>
</div>

<button onclick="new Mark('x')">Добавить отметку X</button>
<button onclick="new Mark('y')">Добавить отметку Y</button>
<button onclick="fasten(this.name)" name="descart">Зафиксировать систему координат</button>
<button onclick="fasten(this.name)" name="graph">Зафиксировать график</button>


<script type="text/javascript">
	var widthSVGdescart = document.body.clientWidth;
	var heightSVGdescart = screen.height * 0.75;
	var centrHSVGdescart = screen.height * 0.75 / 2;
	var centrWSVGdescart = document.body.clientWidth / 2;
	var fastenFlag = {
		"graph": true,
		"descart": true
	};
	var graph;
var countMark = {
	"x": 0,
	"y": 0
};
	var marks = {};
	//Create SVG element
	var svg = d3.select("body")
			.append("svg")
			.attr("width", widthSVGdescart)
			.attr("height", heightSVGdescart);

	var descart = svg.append("g")
			.attr("id", "descart")
			.classed("descart", true);


	descart.append("line")
			.attr("id", "axisY")
			.attr("x1", widthSVGdescart / 2)
			.attr("y1", heightSVGdescart * -10)
			.attr("x2", widthSVGdescart / 2)
			.attr("y2", heightSVGdescart * 10)
			.style({
				"stroke": "red",
				"stroke-width": 1
			});

	descart.append("line")
			.attr("x1", widthSVGdescart / 2)
			.attr("y1", heightSVGdescart * -10)
			.attr("x2", widthSVGdescart / 2)
			.attr("y2", heightSVGdescart * 10)
			.style({
				"stroke": "red",
				"opacity": 0,
				"stroke-width": 30
			});

	descart.append("line")
			.attr("id", "axisX")
			.attr("x1", widthSVGdescart * -10)
			.attr("y1", heightSVGdescart / 2)
			.attr("x2", widthSVGdescart * 10)
			.attr("y2", heightSVGdescart / 2)
			.style({
				"stroke": "red",
				"stroke-width": 1
			});

	descart.append("line")
			.attr("x1", widthSVGdescart * -10)
			.attr("y1", heightSVGdescart / 2)
			.attr("x2", widthSVGdescart * 10)
			.attr("y2", heightSVGdescart / 2)
			.style({
				"stroke": "red",
				"opacity": 0,
				"stroke-width": 30
			});

	var zero = descart.append("circle")
			.attr("id", "zero")
			.attr("cx", centrWSVGdescart)
			.attr("cy", centrHSVGdescart)
			.attr("r", 2)
			.style({
				"stroke": "black",
				"stroke-width": 2
			});

	var marksGroup = descart.append("g")
			.attr("id", "marksGroup");



	function fasten (name) {
		if(name === "descart")descart.classed("descart", fastenFlag[name] = !fastenFlag[name]);
		if(name === "graph")graph.classed("descart", fastenFlag[name] = !fastenFlag[name]);
	}








	function Mark (axes) {
		this.name = "mark_" + axes + countMark[axes]++;
		marks[this.name] = this;
		var self = this;
		this.axes = axes;
		this.input = d3.select("#mark")
				.append("input")
				.attr("name", this.name)
				.attr("type", "text")[0][0];
		this.input.onchange = this.engine.bind(this);
		this.g = descart.append("g")
				.attr("id", this.name);
		var x1, x2, y1, y2, cx, cy;
		if (axes === 'x') {
			this.x = 100;
			this.y = 0;
			x1 = x2 = cx = centrWSVGdescart + 100;
			y1 = centrHSVGdescart - 50;
			y2 = centrHSVGdescart + 50;
			cy = centrHSVGdescart;
			this.g.classed("pointx", true)
		} else {
			this.x = 100;
			this.y = 0;
			x1 = centrWSVGdescart - 50;
			x2 = centrWSVGdescart + 50;
			cx = centrWSVGdescart;
			y1 = y2 = cy =centrHSVGdescart - 100;
			this.g.classed("pointy", true)
		}


		this.g.append("line")
				.attr("x1", x1)
				.attr("y1", y1)
				.attr("x2", x2)
				.attr("y2", y2)
				.style({
					"stroke": "red",
					"stroke-width": 1
				});
		this.g.append("line")
				.attr("id", "area")
				.attr("x1", x1)
				.attr("y1", y1)
				.attr("x2", x2)
				.attr("y2", y2)
				.style({
					"stroke": "red",
					"opacity": 0,
					"stroke-width": 30
				});

		this.centr = this.g.append("circle")
				.attr("id", "zero")
				.attr("cx", cx)
				.attr("cy", cy)
				.attr("r", 1)
				.style({
					"stroke": "black",
					"stroke-width": 2
				});

	}

	Mark.prototype.resolveConflict = function (flag, textError) {
		var self = this;
		if (flag) {
			if (!this.conflict || !this.conflict.interval) {
				this.conflict = {};
				this.conflict.flag = true;
				this.conflict.interval = setInterval(function () {
					self.g.select("line#area")
							.transition()
							.duration(500)
							.style({
								"opacity": (function (flag) {
									self.conflict.flag = !flag;
									return flag?1:0;
								})(self.conflict.flag)
							})
				}, 500);
				this.conflict.textError = this.g.append("text")
						.attr("id", "textError")
						.attr("x", centrWSVGdescart + 100)
						.attr("y", centrHSVGdescart - 60)
						.text(textError);
			}
		} else {
			if (this.conflict && this.conflict.interval) {
				clearInterval(this.conflict.interval);
				this.conflict.interval = 0;
				this.g.select("#textError")
						.remove();
				this.g.select("line#area")
						.transition()
						.duration(500)
						.style({
							"opacity": 0
						})
			}
		}
	};

	Mark.prototype.engine = function () {
		this.value = parseFloat(this.input.value);
		if(!this.text) {
			this.text = this.g.append("text");
			if (this.axes === 'x') {
				this.text.attr("x", centrWSVGdescart + 100)
						.attr("y", centrHSVGdescart + 60)
			} else {
				this.text.attr("x", centrWSVGdescart - 65)
						.attr("y", centrHSVGdescart - 105)
			}
		}
		this.text.text(this.value);
		this.calc();
	};




	Mark.prototype.calc = function () {
		if ((this.value * this.x) < 0) {
			this.resolveConflict (true, 'Масштаб не может быть отрицательным')
		} else {
			this.resolveConflict (false)
		}

		console.log(this.value / this.x);
	};


	function eng(event) {
		var mark = marks[event.target.id];
		mark.x += event.dx;
		mark.calc(event.target.id);
	}





function calc (name) {
	var mark = marks[name];
	if ((mark.value * mark.x) < 0) {
		mark.conflict (true, mark, 'Масштаб не может быть отрицательным')
	} else {
		mark.conflict (false, mark)
	}

	console.log(mark.value / mark.x);
}


	interact('.descart')
			.draggable({
				inertia: true,
				restrict: {
					elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
				},
				onmove: function (event) {
					var target = event.target,
							x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
							y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
					// translate the element
					target.style.webkitTransform =
							target.style.transform =
									'translate(' + x + 'px, ' + y + 'px)';

					// update the posiion attributes
					target.setAttribute('data-x', x);
					target.setAttribute('data-y', y);
				},
				// call this function on every dragend event
				onend: function (event) {
					var textEl = event.target.querySelector('p');

					textEl && (textEl.textContent =
							'moved a distance of '
							+ (Math.sqrt(event.dx * event.dx +
							event.dy * event.dy)|0) + 'px');
				}
			});

	interact('.pointx')
			.draggable({
				// enable inertial throwing
				inertia: true,
				// keep the element within the area of it's parent
				restrict: {
					elementRect: { left: 0, right: 0, top: 1, bottom: 1 }
				},

				// call this function on every dragmove event
				onmove: function (event) {
					var target = event.target,
					// keep the dragged position in the data-x/data-y attributes
							x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
							y = 0;
					// translate the element
					target.style.webkitTransform =
							target.style.transform =
									'translate(' + x + 'px, ' + y + 'px)';
					eng(event);

					// update the posiion attributes
					target.setAttribute('data-x', x);
					target.setAttribute('data-y', y);
				},
				// call this function on every dragend event
				onend: function (event) {
					var textEl = event.target.querySelector('p');
					textEl && (textEl.textContent =
							'moved a distance of '
							+ (Math.sqrt(event.dx * event.dx +
							event.dy * event.dy)|0) + 'px');
				}

			});

	interact('.pointy')
			.draggable({
				// enable inertial throwing
				inertia: true,
				// keep the element within the area of it's parent
				restrict: {
					elementRect: { left: 0, right: 0, top: 1, bottom: 1 }
				},

				// call this function on every dragmove event
				onmove: function (event) {
					var target = event.target,
					// keep the dragged position in the data-x/data-y attributes
							x = 0,
							y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
					// translate the element
					target.style.webkitTransform =
							target.style.transform =
									'translate(' + x + 'px, ' + y + 'px)';
					eng(event);

					// update the posiion attributes
					target.setAttribute('data-x', x);
					target.setAttribute('data-y', y);
				},
				// call this function on every dragend event
				onend: function (event) {
					var textEl = event.target.querySelector('p');
					textEl && (textEl.textContent =
							'moved a distance of '
							+ (Math.sqrt(event.dx * event.dx +
							event.dy * event.dy)|0) + 'px');
				}

			});






</script>

<!--<script>window.FileAPI = { staticPath: '/js/FileAPI/dist/' };</script>-->
<!--<script src="/js/FileAPI/dist/FileAPI.min.js"></script>-->
<script>
	FileAPI.event.on(choose, 'change', function (evt){
		var files = FileAPI.getFiles(evt); // Retrieve file list

		FileAPI.filterFiles(files, function (file, info/**Object*/){
			if( /^image/.test(file.type) ){
				return  info.width >= 320 && info.height >= 240;
			}
			return  false;
		}, function (files/**Array*/, rejected/**Array*/){
			if( files.length ){

				graph = svg.insert("image", 'g#descart')
						.classed("descart", true)
						.attr("xlink:href", files[0].name)
						.attr("x", 0)
						.attr("y", 0)
						.attr("height", 483)
						.attr("width", 736);



				// Загружаем файлы
			}
		});
	});
</script>

</body>
</html>